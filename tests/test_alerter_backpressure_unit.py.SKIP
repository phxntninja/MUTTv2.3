# =====================================================================
# MUTT v2.5 Alerter Service Backpressure Unit Tests
# =====================================================================
# Tests for alerter_service.py backpressure logic
# Run with: pytest tests/test_alerter_backpressure_unit.py -v
# =====================================================================

import pytest
from unittest.mock import Mock, MagicMock, patch
import threading

# Import the function to test
from alerter_service import _main_loop_iteration

# Mark all tests in this file as unit tests
pytestmark = pytest.mark.unit

@pytest.fixture
def mock_config():
    """Provides a mock Config object."""
    config = Mock()
    config.INGEST_QUEUE_NAME = "mutt:ingest_queue"
    config.ALERTER_DLQ_NAME = "mutt:dlq:alerter"
    config.BRPOPLPUSH_TIMEOUT = 1
    return config

@pytest.fixture
def mock_redis_client():
    """Provides a mock Redis client."""
    return Mock()

@pytest.fixture
def mock_dependencies():
    """Provides a dictionary of mocked dependencies for the loop iteration."""
    return {
        "db_pool": Mock(),
        "cache_manager": Mock(),
        "matcher": Mock(),
        "processing_list": "mutt:processing:alerter:test-pod",
        "stop_event": threading.Event()
    }

# =====================================================================
# Test Class for Alerter Backpressure
# =====================================================================

class TestAlerterBackpressureLogic:
    """
    Tests the backpressure logic within the _main_loop_iteration function.
    """

    @patch('alerter_service.time.sleep')
    @patch('alerter_service.logger')
    @patch('alerter_service.METRIC_ALERTER_SHED_EVENTS_TOTAL')
    @patch('alerter_service._get_alerter_shed_mode', return_value='dlq')
    @patch('alerter_service._get_alerter_queue_shed_threshold', return_value=200)
    @patch('alerter_service._get_alerter_queue_warn_threshold', return_value=100)
    def test_backpressure_dlq_mode_sheds_event(
        self, mock_get_warn, mock_get_shed, mock_get_mode, mock_metric_shed, mock_logger, mock_sleep,
        mock_config, mock_redis_client, mock_dependencies
    ):
        """
        Verify that when queue depth > shed threshold and mode is 'dlq',
        an event is moved to the DLQ and normal processing is skipped.
        """
        # --- Setup ---
        mock_redis_client.llen.return_value = 250  # Above shed threshold
        shed_message = '{"event": "shed me"}'
        mock_redis_client.rpop.return_value = shed_message

        # --- Action ---
        _main_loop_iteration(mock_config, mock_redis_client, **mock_dependencies)

        # --- Assertions ---
        # 1. Correctly checked queue depth
        mock_redis_client.llen.assert_called_once_with(mock_config.INGEST_QUEUE_NAME)

        # 2. Logged the shedding action
        mock_logger.warning.assert_called_once()
        assert "SHEDDING LOAD" in mock_logger.warning.call_args[0][0]

        # 3. Shed the event to DLQ
        mock_redis_client.rpop.assert_called_once_with(mock_config.INGEST_QUEUE_NAME)
        mock_redis_client.lpush.assert_called_once_with(mock_config.ALERTER_DLQ_NAME, shed_message)
        mock_metric_shed.labels.assert_called_once_with(mode='dlq')
        mock_metric_shed.labels.return_value.inc.assert_called_once()

        # 4. Did NOT attempt to process a message
        mock_redis_client.brpoplpush.assert_not_called()

    @patch('alerter_service.time.sleep')
    @patch('alerter_service.logger')
    @patch('alerter_service.METRIC_ALERTER_SHED_EVENTS_TOTAL')
    @patch('alerter_service._dyn_get_int', return_value=500)
    @patch('alerter_service._get_alerter_shed_mode', return_value='defer')
    @patch('alerter_service._get_alerter_queue_shed_threshold', return_value=200)
    @patch('alerter_service._get_alerter_queue_warn_threshold', return_value=100)
    def test_backpressure_defer_mode_sleeps(
        self, mock_get_warn, mock_get_shed, mock_get_mode, mock_dyn_get, mock_metric_shed, mock_logger, mock_sleep,
        mock_config, mock_redis_client, mock_dependencies
    ):
        """
        Verify that when queue depth > shed threshold and mode is 'defer',
        the function sleeps and does not process an event.
        """
        # --- Setup ---
        mock_redis_client.llen.return_value = 250  # Above shed threshold

        # --- Action ---
        _main_loop_iteration(mock_config, mock_redis_client, **mock_dependencies)

        # --- Assertions ---
        # 1. Logged the defer action
        mock_logger.warning.assert_called_once()
        assert "SHEDDING LOAD" in mock_logger.warning.call_args[0][0]
        mock_logger.info.assert_called_once_with("Deferring processing for 500ms.")

        # 2. Slept for the configured time
        # Called once for defer (0.5s) and once for the tight-loop avoidance (0.05s)
        assert mock_sleep.call_count == 2
        mock_sleep.assert_any_call(0.5)

        # 3. Did NOT shed to DLQ
        mock_redis_client.rpop.assert_not_called()
        mock_redis_client.lpush.assert_not_called()
        
        # 4. Incremented correct metric
        mock_metric_shed.labels.assert_called_once_with(mode='defer')
        mock_metric_shed.labels.return_value.inc.assert_called_once()

        # 5. Did NOT attempt to process a message
        mock_redis_client.brpoplpush.assert_not_called()

    @patch('alerter_service.logger')
    @patch('alerter_service._get_alerter_queue_shed_threshold', return_value=200)
    @patch('alerter_service._get_alerter_queue_warn_threshold', return_value=100)
    def test_backpressure_warning_logs_correctly(
        self, mock_get_warn, mock_get_shed, mock_logger,
        mock_config, mock_redis_client, mock_dependencies
    ):
        """
        Verify a warning is logged when queue depth is between warn and shed thresholds.
        """
        # --- Setup ---
        mock_redis_client.llen.return_value = 150  # Between warn and shed
        mock_redis_client.brpoplpush.return_value = None # Simulate timeout after check

        # --- Action ---
        _main_loop_iteration(mock_config, mock_redis_client, **mock_dependencies)

        # --- Assertions ---
        # 1. Logged the warning
        mock_logger.warning.assert_called_once()
        assert "BACKPRESSURE WARNING" in mock_logger.warning.call_args[0][0]

        # 2. Did NOT log a shedding message
        for call in mock_logger.warning.call_args_list:
            assert "SHEDDING LOAD" not in call[0][0]

        # 3. Did NOT shed or defer
        mock_redis_client.rpop.assert_not_called()
        mock_redis_client.lpush.assert_not_called()

        # 4. Continued to attempt normal processing
        mock_redis_client.brpoplpush.assert_called_once()

    @patch('alerter_service.logger')
    @patch('alerter_service._get_alerter_queue_shed_threshold', return_value=200)
    @patch('alerter_service._get_alerter_queue_warn_threshold', return_value=100)
    def test_no_backpressure_when_queue_is_not_full(
        self, mock_get_warn, mock_get_shed, mock_logger,
        mock_config, mock_redis_client, mock_dependencies
    ):
        """
        Verify no backpressure actions are taken when queue depth is normal.
        """
        # --- Setup ---
        mock_redis_client.llen.return_value = 50  # Below thresholds
        mock_redis_client.brpoplpush.return_value = None # Simulate timeout

        # --- Action ---
        _main_loop_iteration(mock_config, mock_redis_client, **mock_dependencies)

        # --- Assertions ---
        # 1. Did NOT log any warnings
        mock_logger.warning.assert_not_called()

        # 2. Did NOT shed or defer
        mock_redis_client.rpop.assert_not_called()
        mock_redis_client.lpush.assert_not_called()

        # 3. Attempted normal processing
        mock_redis_client.brpoplpush.assert_called_once_with(
            mock_config.INGEST_QUEUE_NAME,
            mock_dependencies["processing_list"],
            timeout=mock_config.BRPOPLPUSH_TIMEOUT
        )
